#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const yargs_1 = __importDefault(require("yargs"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const assert_1 = __importDefault(require("assert"));
const readme_1 = require("./generated/readme");
const util_1 = require("./util");
const chalk_1 = require("chalk");
const debug_1 = __importDefault(require("debug"));
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
const validation_1 = require("./validation");
const info = debug_1.default('readme-sync:info');
const verbose = debug_1.default('readme-sync:verbose');
const argv = yargs_1.default
    .version(false)
    .options({
    'apiKey': { type: 'string', demandOption: true },
    'docs': { type: 'string', demandOption: true },
    'version': { type: 'string', demandOption: true },
    'validateOnly': { type: 'boolean' },
}).argv;
const client = readme_1.createClient({
    fetch: async (url, options) => {
        info(`${options.method} ${url}`);
        verbose('body', options.body);
        verbose('headers', options.headers);
        const response = await isomorphic_fetch_1.default(url, {
            ...options,
            headers: {
                ...options.headers,
                'x-readme-version': argv.version,
                'authorization': `Basic ${Buffer.from(argv.apiKey + ':').toString('base64')}`,
            }
        });
        verbose('response', response);
        return response;
    }
});
async function upsertDoc(remoteTree, categoryName, filepath, options = {}) {
    var _a, _b, _c;
    assert_1.default(fs_1.default.statSync(filepath).isFile());
    const docFileName = path_1.default.parse(filepath).name;
    const slug = (_a = options.slug, (_a !== null && _a !== void 0 ? _a : util_1.slugify(util_1.nameWithoutOrder(docFileName))));
    const existing = remoteTree.get(util_1.slugify(categoryName)).docs.find((doc) => {
        if (doc.slug === slug)
            return true;
        return doc.children.find(child => child.slug === slug);
    });
    const metadata = gray_matter_1.default(fs_1.default.readFileSync(filepath));
    const form = {
        slug,
        title: metadata.data.title,
        body: metadata.content,
        excerpt: metadata.data.excerpt,
        order: (_b = options.order, (_b !== null && _b !== void 0 ? _b : util_1.orderFromName(docFileName))),
        category: remoteTree.get(util_1.slugify(categoryName)).category._id,
        parentDoc: options.parent ? options.parent._id : undefined,
        hidden: (_c = metadata.data.hidden, (_c !== null && _c !== void 0 ? _c : false)),
    };
    const destination = `${util_1.slugify(categoryName)}${options.parent ? ` / ${options.parent.slug}` : ''} / ${slug}`;
    if (existing) {
        console.log(`\tUpdating ${chalk_1.blueBright(filepath)} -> ${chalk_1.green(destination)}`);
        const doc = await client.docs.putBySlug({ slug, body: form });
        info(`updated - ${doc.status}`);
        verbose(doc.body);
        if (doc.status == 400) {
            console.error(`Error: ${doc.body.error} - ${doc.body.description}`);
            if (doc.body.errors != null)
                console.error(doc.body.errors);
            throw new Error(doc.body.description);
        }
        return doc.body;
    }
    else {
        console.log(`\tCreating ${chalk_1.blueBright(filepath)} -> ${chalk_1.green(destination)}`);
        const doc = await client.docs.post({ body: form });
        info(`created - ${doc.status}`);
        verbose(doc.body);
        if (doc.status == 400) {
            console.error(`Error: ${doc.body.error} - ${doc.body.description}`);
            if (doc.body.errors != null)
                console.error(doc.body.errors);
            throw new Error(doc.body.description);
        }
        if (doc.body.slug !== slug) {
            console.error(doc.body);
            throw new Error('Bug. Existing document not updated.');
        }
        return doc.body;
    }
}
/**
 * Insert and update a doc and its children
 *
 * integration/
 * +- index.md
 * +- setup.md
 * +- config.md
 */
async function upsertDir(remoteTree, categoryName, dirpath) {
    assert_1.default(fs_1.default.statSync(dirpath).isDirectory());
    const children = fs_1.default.readdirSync(dirpath);
    if (!children.includes('index.md')) {
        console.error(`ERROR: ${dirpath} requires an index.md page`);
        return;
    }
    const parentName = path_1.default.basename(dirpath);
    const parent = await upsertDoc(remoteTree, categoryName, path_1.default.join(dirpath, 'index.md'), {
        slug: util_1.slugify(util_1.nameWithoutOrder(parentName)),
        order: util_1.orderFromName(parentName),
    });
    for (const child of children) {
        if (child === 'index.md')
            continue;
        await upsertDoc(remoteTree, categoryName, path_1.default.join(dirpath, child), { parent });
    }
}
/**
 * Delete remote docs that are not present locally.
 */
async function deleteNotPresent({ category, docs }, categoryDir) {
    for (const remoteDoc of docs) {
        const localDocDir = fs_1.default.readdirSync(categoryDir).find(d => util_1.slugify(util_1.nameWithoutOrder(d)) === remoteDoc.slug);
        // delete children
        for (const remoteChild of remoteDoc.children) {
            const localChild = localDocDir && fs_1.default.readdirSync(path_1.default.join(categoryDir, localDocDir)).find(d => util_1.slugify(util_1.nameWithoutOrder(path_1.default.parse(d).name)) === remoteChild.slug);
            if (!(localDocDir && localChild && fs_1.default.existsSync(path_1.default.join(categoryDir, localDocDir, localChild)))) {
                console.log(`\tDeleting remote ${chalk_1.redBright(`${category.slug} / ${remoteDoc.slug} / ${remoteChild.slug}`)}`);
                info(`because ${categoryDir}/${localDocDir}/${localChild || (remoteChild.slug + '.md')} doesn't exist`);
                await client.docs.deleteBySlug({ slug: remoteChild.slug });
            }
        }
        const indexMdExists = localDocDir && fs_1.default.existsSync(path_1.default.join(categoryDir, localDocDir, 'index.md'));
        const localDoc = fs_1.default.readdirSync(categoryDir).find(d => util_1.slugify(util_1.nameWithoutOrder(path_1.default.parse(d).name)) === remoteDoc.slug);
        // delete parents
        if (!indexMdExists && !localDoc) {
            console.log(`\tDeleting remote ${chalk_1.redBright(`${category.slug} / ${remoteDoc.slug}`)}`);
            info(`because ${categoryDir}/${localDocDir}/index.md and ${categoryDir}/${remoteDoc.slug}.md don't exist`);
            await client.docs.deleteBySlug({ slug: remoteDoc.slug });
        }
    }
}
/**
 * Insert, update, and delete remote docs.
 *
 * Only two layers of nesting supported
 *
 * category/
 * +- doc1.md
 * +- doc2.md
 * +- group/
 *    +- child.md
 *    +- index.md
 */
async function sync(remoteTree) {
    for (const category of fs_1.default.readdirSync(argv.docs)) {
        if (category.startsWith('.') || !fs_1.default.statSync(path_1.default.join(argv.docs, category)).isDirectory())
            continue;
        console.log(category);
        const categoryPath = path_1.default.join(argv.docs, category);
        for (const doc of fs_1.default.readdirSync(categoryPath)) {
            const docPath = path_1.default.join(categoryPath, doc);
            if (doc.startsWith('.')) {
                continue;
            }
            else if (doc.endsWith('.md')) {
                await upsertDoc(remoteTree, category, docPath);
            }
            else {
                await upsertDir(remoteTree, category, path_1.default.join(argv.docs, category, doc));
            }
        }
        await deleteNotPresent(remoteTree.get(util_1.slugify(category)), path_1.default.join(argv.docs, category));
    }
}
async function main() {
    const remoteTree = new Map();
    let errored = false;
    if (!validation_1.ensureUniqueSlugs(argv.docs))
        process.exit(1);
    if (!validation_1.ensureFrontMatter(argv.docs))
        process.exit(1);
    if (!validation_1.ensureLinksAreValid(argv.docs))
        process.exit(1);
    if (!validation_1.ensureIndexMdExists(argv.docs))
        process.exit(1);
    console.log('Docs look good');
    if (argv.validateOnly) {
        return;
    }
    // we need to fetch the categories from local dir names because there is no API to get this from readme.com
    console.log('Fetching categories');
    for (const localCategoryName of fs_1.default.readdirSync(argv.docs)) {
        if (localCategoryName.startsWith('.') || !fs_1.default.statSync(path_1.default.join(argv.docs, localCategoryName)).isDirectory())
            continue;
        const slug = util_1.slugify(localCategoryName);
        const [remoteCategory, remoteDocs] = await Promise.all([
            client.categories.getBySlug({ slug }),
            client.categories.getDocsBySlug({ slug }),
        ]);
        if (remoteCategory.status == 200 && remoteDocs.status == 200) {
            assert_1.default(remoteCategory.body.slug === slug);
            console.log(`Got ${chalk_1.yellow(localCategoryName)}`);
            remoteTree.set(slug, {
                category: remoteCategory.body,
                docs: remoteDocs.body,
            });
        }
        else {
            if (remoteCategory.status == 404) {
                console.error(`I cannot create categories yet. Please manually create the category ${localCategoryName} (slug ${slug}) in Readme.`);
                errored = true;
            }
            else {
                console.error(remoteCategory);
                console.error(remoteDocs);
                throw new Error('something happened');
            }
        }
    }
    if (errored)
        process.exit(1);
    info(remoteTree);
    await sync(remoteTree);
}
main().catch((err) => {
    console.error(err);
    process.exit(1);
});
