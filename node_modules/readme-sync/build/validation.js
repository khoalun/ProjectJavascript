"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const chalk_1 = require("chalk");
const gray_matter_1 = __importDefault(require("gray-matter"));
const util_1 = require("./util");
function walkDocTree(root, cb, dirCb = () => { }) {
    for (const category of fs_1.default.readdirSync(root)) {
        if (category.startsWith('.') || !fs_1.default.statSync(path_1.default.join(root, category)).isDirectory())
            continue;
        const categoryPath = path_1.default.join(root, category);
        for (const doc of fs_1.default.readdirSync(categoryPath)) {
            const docPath = path_1.default.join(categoryPath, doc);
            if (doc.startsWith('.')) {
                continue;
            }
            else if (doc.endsWith('.md')) {
                cb(docPath, false);
            }
            else if (!fs_1.default.statSync(docPath).isDirectory()) {
                console.warn(`Warning: ${docPath} is not a .md file nor a directory`);
            }
            else {
                dirCb(docPath);
                for (const child of fs_1.default.readdirSync(docPath)) {
                    const childPath = path_1.default.join(docPath, child);
                    if (child.startsWith('.')) {
                        continue;
                    }
                    else if (child.endsWith('.md')) {
                        cb(childPath, true);
                    }
                }
            }
        }
    }
}
function validateFrontMatter(docPath, content) {
    const frontmatter = gray_matter_1.default(content);
    const { title, hidden } = frontmatter.data;
    let passed = true;
    for (const key of Object.keys(frontmatter.data)) {
        if (!['title', 'hidden', 'excerpt'].includes(key)) {
            console.log(`Error: ${chalk_1.redBright(docPath)}: invalid frontmatter key ${key}`);
            passed = false;
        }
    }
    if (title == null || typeof title !== 'string') {
        console.error(`Error: ${chalk_1.redBright(docPath)}: title missing or invalid`);
        passed = false;
    }
    if (hidden != null && typeof hidden !== 'boolean') {
        console.error(`Error: ${chalk_1.redBright(docPath)}: hidden must be true or false`);
        passed = false;
    }
    return passed;
}
/** Ensure that all files have valid frontmatter */
function ensureFrontMatter(docs) {
    let passed = true;
    walkDocTree(docs, (docPath) => {
        passed = passed && validateFrontMatter(docPath, fs_1.default.readFileSync(docPath));
    });
    return passed;
}
exports.ensureFrontMatter = ensureFrontMatter;
function ensureUniqueSlugs(docs) {
    const slugs = {};
    let passed = true;
    walkDocTree(docs, (docPath, isChild) => {
        let parsedPath = path_1.default.parse(docPath);
        if (isChild && parsedPath.base === 'index.md') {
            parsedPath = path_1.default.parse(parsedPath.dir); // use parent slug
        }
        const slug = util_1.slugify(util_1.nameWithoutOrder(parsedPath.name));
        if (Object.keys(slugs).includes(slug)) {
            console.error(`Error: ${chalk_1.redBright(docPath)} has the same slug as ${chalk_1.redBright(slugs[slug])}`);
            passed = false;
        }
        else {
            slugs[slug] = docPath;
        }
    });
    return passed;
}
exports.ensureUniqueSlugs = ensureUniqueSlugs;
function ensureLinksAreValid(docs) {
    let passed = true;
    const slugs = [];
    const link = /\[(?<text>[^)\n]+)\]\(doc:(?<target>[A-Za-z0-9-]+)(#[A-Za-z0-9-]+)?\)/g;
    // Step 1: Gather all doc slugs
    walkDocTree(docs, (docPath, isChild) => {
        if (isChild && path_1.default.basename(docPath) == 'index.md')
            slugs.push(util_1.slugify(util_1.nameWithoutOrder(path_1.default.parse(path_1.default.dirname(docPath)).name)));
        else
            slugs.push(util_1.slugify(util_1.nameWithoutOrder(path_1.default.parse(docPath).name)));
    });
    // Step 2: Check that each link points to a valid slug
    walkDocTree(docs, (docPath) => {
        const contents = fs_1.default.readFileSync(docPath).toString();
        for (const match of contents.matchAll(link)) {
            if (!slugs.includes(match.groups.target)) {
                passed = false;
                console.error(`Broken link ${chalk_1.underline(chalk_1.blueBright(`[${match.groups.text}](doc:${match.groups.target})`))} in ${chalk_1.green(docPath)}`);
            }
        }
    });
    return passed;
}
exports.ensureLinksAreValid = ensureLinksAreValid;
function ensureIndexMdExists(docs) {
    let passed = true;
    walkDocTree(docs, () => { }, (dir) => {
        if (!fs_1.default.readdirSync(dir).includes('index.md')) {
            console.error(`Error: "${dir}" has no index.md`);
            passed = false;
        }
    });
    return passed;
}
exports.ensureIndexMdExists = ensureIndexMdExists;
